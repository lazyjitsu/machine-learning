<canvas
  id="myCanvas"
  width="600px"
  height="600px"
  style="background-color: white"
>
</canvas>
<canvas
  id="chartCanvas"
  width="600px"
  height="100px"
  style="background-color: white"
>
</canvas>
<style>
  body {
    background-color: black;
    margin: 0;
    overflow: hidden;
  }
</style>

<script>
  const ctx = myCanvas.getContext("2d");
  const chartCtx = chartCanvas.getContext("2d");

  const offset = {
    x: myCanvas.width / 2,
    y: myCanvas.height / 2,
  };
  const chartOffset = {
    x: chartCanvas.width / 2,
    y: chartCanvas.height / 2,
  };

  let theta = Math.PI / 4; // 45 deg
  const c = 100; // hypotenuse
  //  c simplifies and we just left with the length of x and y
  const A = { x: 0, y: 0 };
  const B = { x: Math.cos(theta) * c, y: Math.sin(theta) * c };
  const C = { x: B.x, y: 0 };
  ctx.translate(offset.x, offset.y);
  chartCtx.translate(chartOffset.x, chartOffset.y);
  drawCoordinateGrid(chartCtx, chartOffset);

  update();
  document.onwheel = (e) => {
    //console.log(-Math.sign(e.deltaY)); // make up positive and down negative
    theta -= toRadians(Math.sign(event.deltaY)); // theta either 1 or -1
    // don't think of theta as an angle...now its more like the distance traveled around the circle

    B.x = Math.cos(theta) * c;
    B.y = Math.sin(theta) * c;

    C.x = B.x;

    update();
  };

  drawCoordinateGrid(ctx, offset);

  function update() {
    const sin = Math.sin(theta);
    const cos = Math.cos(theta);
    const tan = Math.tan(theta); // iow: a/b if u cancel out the c

    const T = {
      x: Math.sign(cos) * Math.hypot(1, tan) * c,
      y: 0,
    };
    ctx.clearRect(-offset.x, -offset.y, myCanvas.width, myCanvas.height);
    drawCoordinateGrid(ctx, offset);

    drawText(
      "sin = a " + sin.toFixed(2),
      {
        x: -offset.x / 2,
        y: offset.y * 0.6,
      },
      "red"
    );
    drawText(
      "cos = b " + cos.toFixed(2),
      {
        x: -offset.x / 2,
        y: offset.y * 0.5,
      },
      "blue"
    );
    drawText(
      "tan" + tan.toFixed(2),
      {
        x: -offset.x / 2,
        y: offset.y * 0.4,
      },
      "magenta"
    );
    drawText(
      "θ=" +
        theta.toFixed(2) +
        " (" +
        Math.round(toDegree(theta)).toString().padStart(2, " ") +
        "°)",
      { x: offset.x / 2, y: offset.y * 0.7 }
    );

    // console.log("Theta ", theta, Math.sin(theta), c);

    drawLine(A, B);
    drawText("1", average(A, B));
    drawLine(A, C, "blue");
    drawText("cos", average(A, C));
    drawLine(B, C, "red");
    drawText("sin", average(B, C));
    drawLine(B, T, "magenta");
    drawText("tan", average(B, T));

    drawText("θ", A);

    ctx.beginPath();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    // now we set 'c' to 100 but we have to image its 1. If we set it to 1, we couldn't see anything! Ratios are same so it doesn't matter. So we will put 1 for hypotenuse even though we know its 100
    ctx.arc(0, 0, c, 0, theta, theta < 0);

    ctx.stroke();
    const chartScaler = chartOffset.y * 0.5;
    drawPoint(
      chartCtx,
      { x: theta * chartScaler, y: sin * chartScaler },
      4,
      "red"
    );
    drawPoint(
      chartCtx,
      { x: theta * chartScaler, y: cos * chartScaler },
      4,
      "blue"
    );
    drawPoint(
      chartCtx,
      { x: theta * chartScaler, y: tan * chartScaler },
      4,
      "magenta"
    );
  }

  function toDegree(rad) {
    return (rad * 180) / Math.PI;
  }
  function toRadians(deg) {
    return (deg * Math.PI) / 180;
  }
  function average(p1, p2) {
    return {
      x: (p1.x + p2.x) / 2,
      y: (p1.y + p2.y) / 2,
    };
  }
  function distance(p1, p2) {
    // return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    return Math.hypot(p1.x - p2.x, p1.y - p2.y);
  }
  function drawText(text, loc, color = "black") {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "bold 18px Courier";
    ctx.strokeStyle = "white";
    ctx.lineWidth = 7;
    ctx.strokeText(text, loc.x, loc.y);
    ctx.fillText(text, loc.x, loc.y);
  }
  function drawLine(p1, p2, color = "black") {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }
  function drawPoint(ctx, p, size = 20, color = "black") {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(p.x, p.y, size / 2, 0, Math.PI * 2);
    ctx.fill();
  }
  function drawCoordinateGrid(ctx, offset) {
    // Coordinate System
    ctx.beginPath();
    ctx.strokeStyle = "lightgray";
    ctx.setLineDash([10, 12]);
    ctx.moveTo(-offset.x, 0);
    ctx.lineTo(ctx.canvas.width - offset.x, 0);
    ctx.moveTo(0, -offset.y);
    ctx.lineTo(0, ctx.canvas.height - offset.y);
    ctx.stroke();
    ctx.setLineDash([]);
  }
</script>
